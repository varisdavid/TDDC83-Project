\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1.2in]{geometry}

%Package enabling roman numerals in lists
\usepackage{enumitem}

%Package enabling dashed lines
\usepackage{arydshln}

%Package for links
\usepackage[hidelinks]{hyperref} 

%Displaying code
\usepackage{listings}
\lstdefinelanguage{AQL}{%
  language     = SQL,
  morekeywords = {CONTAINS, OFFSET}
}

%Package to show images
\usepackage{graphicx}
\graphicspath{ {./images/} }

%Package to display requirements as in SRS
\usepackage{tabularx}

\title{Architecture Notebook}

\author{Jonas Malm}
\date{Fall 2020\\---\\Version 3.2}

\begin{document}

\maketitle

\begin{centering}
\includegraphics[scale=0.7]{logo-heartbyte}
\end{centering}

\clearpage

\newgeometry{margin=0.7in}
\begin{table}
\section*{Version history}
\centering
\begin{tabular}{|l|l|l|p{7cm}|p{3cm}|}
\hline
Version & Date & Author & Description & Approved by \\ \hline
0.1 & 2020-10-15 & Jonas Malm & Creation of document & \\ 
0.2 & 2020-10-16 & Jonas Malm & Added architectural goals, finished ASRs & \\
0.3 & 2020-11-02 & Jonas Malm & Added architectural constrains & \\ 
0.4 & 2020-11-02 & Jonas Malm & Added architectural decisions & \\
0.5 & 2020-11-04 & Jonas Malm & Refined decisions and ASRs & \\
0.6 & 2020-11-04 & Jonas Malm & Added key abstractions and started layers & \\
0.7 & 2020-11-05 & Jonas Malm & Wrote detailed layers & \\
0.8 & 2020-11-09 & Jonas Malm & Added a glossary & \\
0.9 & 2020-11-09 & Jonas Malm & Mades revisions based on feedback from Gustaf Eriksson & Gustaf Eriksson\\
0.10 & 2020-11-09 & Jonas Malm & Re-wrote ASR to facilitate traceability & \\
0.11 & 2020-11-10 & Jonas Malm & Added user cases & \\
0.12 & 2020-11-10 & Jonas Malm & Modified box and line to separate filtration module & \\
0.13 & 2020-11-10 & Jonas Malm & Added overview sequence diagram & \\
0.14 & 2020-11-11 & Jonas Malm & Started work on the authentication section & \\
0.15 & 2020-11-12 & Jonas Malm & Added new section to arch. decisions: Using Auth0 & \\
0.16 & 2020-11-13 & Jonas Malm & Added subsection to AD: Role-based access control & \\
0.17 & 2020-11-13 & Jonas Malm & Added RBAC Roles to authentication section & \\
0.18 & 2020-11-13 & Jonas Malm & Added an authentication sequence diagram & \\
0.19 & 2020-11-13 & Jonas Malm & Added Patient View sequence diagram & \\ \hline
1.0 & 2020-11-24 & Jonas Malm & Revisions after inspection & Patrik Palmgren\\
1.1 & 2020-11-16 & Jonas Malm & Added Placement of modules in Arch. dec. section & \\
1.2 & 2020-11-16 & Jonas Malm & Wrote the scaleability in future section & \\
1.3 & 2020-11-18 & Jonas Malm & Wrote the support in future section & \\
1.4 & 2020-11-18 & Jonas Malm & Started maintainability in future section & \\
1.5 & 2020-11-18 & Jonas Malm & More maintainabillity: more data and replacing EhrScape & \\
1.6 & 2020-11-20 & Jonas Malm & Fixed inconsistencies in how HCU were named & \\
1.7 & 2020-11-20 & Jonas Malm & Future dev: Added trend analysis and two figures & \\
1.8 & 2020-11-22 & Jonas Malm & Future dev: Added advanced notification log and one figure & \\
1.9 & 2020-11-22 & Jonas Malm & Future dev: Added tweaking rule engine & \\
1.10 & 2020-11-24 & Jonas Malm & Following the release of SRS v2.0, re-wrote the ASR section & \\
1.11 & 2020-11-24 & Jonas Malm & Some re-structuting and smaller changes before inspection & \\ 
\hline
\end{tabular}
\end{table}

\begin{table}
\centering
\begin{tabular}{|l|l|l|p{7cm}|p{3cm}|}
\hline
Version & Date & Author & Description & Approved by \\ \hline
2.0 & 2020-11-25 & Jonas Malm & Made revisions from results of inspections & Emma Johansson\\
2.1 & 2020-11-25 & Jonas Malm & RBAC will not be used and changes were made to auth section to reflect this. Added RBAC to system in the future. & \\
2.2 & 2020-11-26 & Jonas Malm & Added Auth0 server to box-and-line diagram and subsection & \\
2.3 & 2020-11-26 & Jonas Malm & Due to new information from analysts all access shall be logged and not just the unauthorized. Thus made changes to reflect this in 5.2.3, 3.1 and 5.3. & \\
2.4 & 2020-11-26 & Jonas Malm & Updated key abstractions figure to include auth server. Re-wrote parts of key abstractions. & \\
2.5 & 2020-11-30 & Jonas Malm & Added all templates, archetypes and AQL queries used with EhrScape to the appendix. Added references to the appendix. & \\
2.6 & 2020-12-03 & Jonas Malm & Added section about database migration: SQlite to PostgreSQL & \\
2.7 & 2020-12-03 & Jonas Malm & Extended dependency section & \\
2.8 & 2020-12-03 & Jonas Malm & Added deployment view & \\ \hline
3.0 & 2020-12-09 & Jonas Malm & Made revisions from result of inspections & Emma Johansson\\ 
3.1 & 2020-12-09 & Jonas Malm & Added final corrections to the Future dev: RBAC section to illustrate some functionality that was not implemented & \\
3.2 & 2020-12-09 & Jonas Malm & Added links to all documents referenced & \\
\hline
\end{tabular}
\end{table}

\restoregeometry
\clearpage

\tableofcontents
\clearpage

\section{Introduction}
\subsection{Purpose}
This document describes the software architecture of the system. Furthermore it describes the software modules that will be built and incorporated into the system, and delivers an overview of their function as well as an description of how they will support the project's goals.

\subsection{Definitions, acronyms and abbreviations}
\begin{description}
\item [EHR] An \emph{Electronic Health Record} is a record containing patient health data in an electronic form.
\item [OpenEHR] is a collection of open industry specifications, models and software for e-health.
\item [AQL] The \emph{Archetype Query Language} is a declarative query language developed to search and retrieve data in archetype-based repositories, such as an OpenEHR-database.
\item [HCU] An abbreviation of Health Care Unit.
\item [OAuth] An open standard for authorization delegation. It allows a service owner to allow third-party server access without sharing credentials, instead using access tokens. 
\item [RBAC] Role-Based Access Control is a way to assign access levels based on what role a user has.
\item [Auth0] A drop-in solution that simplifies the implementation of authentication.
\end{description}

\subsection{Goal of the project}
The key goal of HeartByte's product is to provide health care providers an easy-to-use system to monitor and care for a large group of patient with limited resources. Thus the architecture of this software contains modules that enable health care providers to gain an overview over a large group of patient while identifying key patients through autonomous classification and manual filtration and sorting, as well as supporting components.

\subsection{Architectural goals}
The goal of the architecture is to reach the project goal while fulfilling a few software specific goals. The customer has expressed a wish that the software be designed and build in accordance to the aspects below.

\subsubsection{Achieving high modularity with pre-built components}
The customer, Region Östergötland, wants to be able to combine parts from different systems together. In order for it to be possible to combine parts of HeartByte's software with parts from other systems, the software needs to be designed in a way so it maintains a high degree of modularity and a high degree of cohesion within modules. Otherwise combining functionality from HeartByte's software with other systems would be very difficult. Using pre-built, standardized components further enables this, since they are easily replaced and modular by definition.

\subsubsection{Ensuring integration with existing systems is easy}
In order to facilitate a simple integration process into existing systems the architecture needs to take existing systems into consideration. This includes loading and storing patient data in the same format as existing systems, loading and storing care giver data in the same format as existing systems and using the same kind of authentication method. The customer has their EHRs stored in the OpenEHR format and implements an Identity Management solution using OAuth 2.0.

\subsubsection{Creating software independent of OS and platform}
Furthermore, the customer wants a system that can be used from different operating systems as well as platforms. The software's interface should be web based. Some care givers might use tablets running iOS while others use Android and others still use a computer or even a smartphone. In conclusion it is important for the customer that the system can be accessed and used from a multitude of OSs and platforms, which will have implications on the architecture and the choice of stack. Since the developed software will be a web app, this goal means that the web app can be used from different web browsers on various platforms.


\subsection{Architectural constraints}
Due to the nature of the project, there are several constraints which have to be considered. Most importantly, the time frame and the skills of the development team.


\subsubsection{Time constraint}
According the the \href{https://gitlab.liu.se/tddc88-company-3-2020/deploy/-/tree/Document_branch/Project_Plan}{\underline{Project Plan}}, the project is to be finished in about three months. The first month, iteration 0 and 1, is spent setting up an organizational structure, communicating with the customer to elicit needs and creating requirements and then one week of education for the development team. Then there are two weeks of developing in iteration 2, two weeks in iteration 3 and one week in iteration 4. 
Thus there are only five weeks where the system is to be developed. If the project is to be completed on time, these five weeks will have to be used effectively. The architecture of the system will have to reflect this and thus focus on creating the modules that add the most value to the customer, while using pre-built components as much as possible.

\subsubsection{Skill constraint}
Since there is only one week for educating the development team, the choice of stack will have to reflect this and try to leverage existing knowledge over creating new. According to the skill set study by \emph{Configuration Manager Sam Anlér}, the team is proficient in these languages:

\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|}
\hline
Language & Number of proficient users & Share of team \\ \hline
Java & 23 & 88\% \\
HTML & 20 & 77\% \\ 
JavaScript & 18 & 69\% \\ 
SQL & 18 & 69\% \\ 
Python & 15 & 58\% \\ 
\hline
\end{tabular}
\end{table}



\subsection{Assumptions and dependencies}
\subsubsection{Assumptions}
\begin{enumerate}[label=(\roman*)]
\item The system will not be used on smart phones, thus platform and OS independence applies only to computers and tablets. 
\item The customer uses a openEHR system to store EHRs, and the same templates as the ones implemented in the HeartByte system.
\item The rules used in the rule engine are set by the HCUs admin and not by HeartByte. HeartByte thus cannot take responsibility over if scientifically correct rules are applied, only that the patients are prioritized according to them.
\end{enumerate}
\subsubsection{Dependencies}
\begin{enumerate}[label=(\roman*)]
\item In order to create an accurate representation of the authentication, we require information from the customer about the structure of their personnel database. Otherwise it will be more difficult to integrate the HeartByte authentication solution with the customer's existing solution.
\item Because of the tight time constraint as well as no developer being familiar with openEHR, the development team will require som guidance from RÖ on how to use openEHR.

\end{enumerate}

\section{Architecturally significant requirements}
Listed below are the Architecturally significant requirements (ARSs), the requirements most central to the architectural design. They are all from the \href{https://gitlab.liu.se/tddc88-company-3-2020/deploy/-/tree/Document_branch/Software\%20Requirements\%20Specification}{\underline{Software Requirements Specification}} document.

\subsection{Main views}
In the SRS there are a few key requirements specifying the properties of the two views: the overview and the patient view. Below, ASRs concerning these two views will be presented.

\subsubsection{Patient overview}

\begin{tabularx}{\linewidth}{| l |  X |}
\hline
\textbf{ID, Title} & FR006, Set limit values for priority levels  \\ 
\hline
\textbf{Input}: & Limit values for different measurements in text fields with specific IDs and click "save"-button with ID = "patientViewAdminBtnValue".\\
\textbf{Action}: & System saves and sets patient specific prioritization limits \\
\textbf{Output}: & Settings displayed \\
\hline

\textbf{ID, Title} & FR034, Sorting patients  \\ 
\hline
\textbf{Input}: & Click on one of the column titles (Namn, Personnummer, Prioritet, Diagnos, Senast Uppdaterad, Uppdaterad av, Team). Each column title shall have its own ID. Click once for descending alphabetical order OR click twice for descending alphabetical order.  \\
\textbf{Action}: & The system rearranges the list of patients according to sorting criteria. \\
\textbf{Output}: & The system displays all patients according to the sorting criteria\\ 
\hline

 \textbf{ID, Title} & FR031, Filtering patients  \\ 
 \hline
 \textbf{Input}: &  Click on "Filter"-buttonfilter and insert values from categories [Ålder, Prioritering, Verksamhet, Avdelning, Team, Diagnos]. \\
\textbf{Action}: & The system searches for patients matching filter criteria. \\
\textbf{Output}: & The system displays all patients who matched the filters.\\
\hline
\end{tabularx}
\\ \\
There are also several requirements specifying the need for customizing a filter view. A filter view is a set of filters applied to a list of patients. Identical requirements are repeated for different tabs and user classes, so here only one is mentioned. This filter view creator is visible in four contexts, and thus there are four sets of requirements. The ID of the two filtering requirements below are written about the context of an admin handling the patients belonging to the admin's HCU. The difference between the functionality for an admin and for a regular user, is that an admin can save filter views visible to an entire group of user whereas a regular user only can save it for personal use. Thus the \emph{output} of the \emph{Confirm created view} differs between an admin and a user context.

\begin{tabularx}{\linewidth}{| l |  X |}
\hline
\textbf{ID, Title} & FR003, Create new view \\ 
\hline
\textbf{Input:} & Button with ID = "adminOverviewMyPatientsNewViewBtn" is pressed \\
\textbf{Action:} & System loading new window with customization settings \\
\textbf{Output:} & Pop-up window with customization settings options is displayed \\
\hline

\textbf{ID, Title} & FR044, Confirm created view \\ 
\hline
\textbf{Input:} & Title of new view in text field with ID "saveNewView", the selected user group in drop-down menu with ID "viewAvailableFor" and sign button with ID "confirmCustomizedView" \\
\textbf{Action:} & System generates new view based on previously selected settings and saves to database. \\
\textbf{Output:} & New view available for all users in the chosen user group. \\
\hline
\end{tabularx}
\\ \\
All the four requirement sets for creating views also contain six more requirements that specify which parameters can be used to create a filter. For the requirements below, \textbf{FR003} and \textbf{FR044}, these are listed below.
\begin{table}[h]
\centering
\begin{tabular}{|l|l|}
\hline
ID & Content \\ \hline
\textbf{FR038} & Filter by age \\
\textbf{FR039} & Filter by gender \\
\textbf{FR040} & Filter by team \\
\textbf{FR041} & Filter by department \\
\textbf{FR042} & Filter by priority \\
\textbf{FR043} & Filter by diagnosis \\
\hline
\end{tabular}
\end{table}
\\ \\
Summarizing these requirements, they state that the software shall have an overview of patients where a health care provider can:
\begin{enumerate}[label=(\roman*)]
\item prioritize patients assisted by a module implementing care unit-specific triage rules set by an admin,
\item sort patients,
\item filter patients based on multiple criteria,
\item save and load these filter views for later use.
\end{enumerate}
Thus a rule engine will be implemented that loads rule sets created by an admin as well as a database storing custom filter views and custom rules.


\subsubsection{Patient view}
\begin{tabularx}{\linewidth}{| l |  X |}
\hline
\textbf{ID, Title} & NFR025, Patient measurements \\ 
\hline
\textbf{Statement}: & The system shall present measurement history in a diagram \\
\hline

\textbf{ID, Title} & FR011, Detailed graph and list of measurement \\ 
\hline
\textbf{Input}: & Click on a measurement value in a graph. Each graph and measurement value point shall have its own ID. \\
\textbf{Action}: & Load diagram and list of measurements \\
\textbf{Output}: & Display diagrams and list of measurements \\
\hline


\textbf{ID, Title} & NFR027, Personal information \\ 
\hline
\textbf{Statement}: & Personal information (gender, age, personal number) of the
patient shall be included in the view. \\
\hline

\textbf{ID, Title} & NFR028, Personal information: contacts \\ 
\hline
\textbf{Statement}: & Contact information and emergency contacts, if available, shall
be included in the view. \\
\hline

\textbf{ID, Title} & NFR034, Medication information \\ 
\hline
\textbf{Statement}: & Display a list of all of patient’s current medications \\
\hline

\textbf{ID, Title} & NFR032, Diagnoses \\ 
\hline
\textbf{Statement}: & In the view of the patient the current diagnosis/diagnoses shall
be presented in the heading \\
\hline
\end{tabularx}
\\ \\
The requirements state that detailed information about a patient from his or her EHR is to be displayed in a dedicated view for the specific patient. This information includes current medications, next of kin, health data visualized in graphs as well as the diagnoses the patient has.

\subsection{Health data}
There are several specific requirements regarding the health data and EHRs. These, along with their implications, are specified below.

\subsubsection{Format}
\begin{tabularx}{\linewidth}{| l | X |}
\hline
\textbf{ID, Title} & NFR013, OpenEHR \\ 
\hline
\textbf{Statement}: & The system shall enable use of openEHR platforms as storage backend for EHR content (e.g. measurements, content from forms filled out by the patient and care plan) \\
\hline
\end{tabularx}
\\ \\
The requirements further stipulate that all patient \emph{Electronic Health Records}, EHRs, have to be stored and loaded from databases in accordance with the \emph{openEHR open standard specification}. This is furthermore of great importance to the customer, since they cannot integrate the software with its existing software and servers without this key requirement being fulfilled.

\subsubsection{Access}
\begin{tabularx}{\linewidth}{| l |  X |}
\hline
\textbf{ID, Title} & FR032, Active choice of accessing patient information outside of user's unit \\ 
\hline
\textbf{Input}: & Clicking on a patient in overview \\
\textbf{Action}: & The system checks if user wants to access patient data. \\
\textbf{Output}: & Display message checking if user wants to access data. \\
\hline

\textbf{ID, Title} & FR033, Accessing patient information outside of user's unit \\ 
\hline
\textbf{Input}: & Clicking on "Bekräfta" button to access patient data \\
\textbf{Action}: & The system confirms that data shall be displayed \\
\textbf{Output}: & The system displays patient data \\
\hline

\textbf{ID, Title} & FR015, Log users accessing patient information \\ 
\hline
\textbf{Input}: & Patient profile page is accessed by user \\ 
\textbf{Action}: & System logs user ID, date and activity as "Besökte", saves to database and updates activity log. \\ 
\textbf{Output}: & Updated activity log with information regarding user, date and activity. \\
\hline

\textbf{ID, Title} & NFR002, OAuth \\ 
\hline
\textbf{Statement}: & OAuth shall be used for login and authentication.\\
\hline
\end{tabularx}
\\ \\
Health records are highly regulated and one important aspect is who is allowed to see what patient data. Thus the requirements state that the software shall save logs when a user accesses EHRs. The requirements also state that the users have to authenticate themselves using OAuth. 
Thus the following modules need to be implemented:

\begin{enumerate}[label=(\roman*)]
\item A database storing access logs
\item A database storing which Health Care Unit (HCU) a user belongs to, so it can be determined if a user has authority to access
\item An authentication system using OAuth
\end{enumerate}

\section{Architectural decisions}
Below are the most important architectural decisions listed, derived from the architectural goals, the architectural constraints and the ASRs.

\subsection{Using a back end}
In order to accommodate the two database mentioned in the \emph{Access ASR} as well as the customization databases, a back end containing the access log and personnel databases needs to be implemented. This is because in order to ensure that EHRs are not served to unauthorized clients, the calls to the actual EHR Database will have to go through a server that logs access. Doing this client side would not be as secure since a modified client could simply bypass the logging.

\subsection{Choice of front end stack}
The front end will be developed using the JavaScript framework ReactJS. This is due to a few reasons:

\begin{enumerate}[label=(\roman*)]
\item By building a web app and using React, \emph{platform and OS independence} is enabled.
\item Due to the skill constraint, we want to leverage existing knowledge. The team is proficient in JavaScript and \emph{React is a JavaScript framework}.
\item Due to the time constraint, we need a language that is \emph{quick to learn and simple to use}. This holds true for React, which due to its wide spread use has many tutorials and good documentation.
\item One of the architectural goals is to achieve \emph{high modularity through reusable components}. React facilities this through allowing developers to split the UI into independent components and there are many free open-source components because of the popularity of the framework enabling quick development.
\end{enumerate}

Due to the constraints we want to leverage the development team's existing knowledge. There were some discussions about using TypeScript for front end purposes, but this language will not be used in order to speed up the learning and thus the development process.

\subsection{Choice of back end stack}
Due to the time and skill constraints, this back end and the databases would ideally leverage existing knowledge in the team. The back end will be developed in Python, using the web framework Flask for the server and the framework SQL Alchemy for the databases. The rationale behind these decisions is explained below.

\subsubsection{Python}
Python is a language that is easy to work with and easy to read; is easy to read, very popular as a back end language which ensures good help and has many web application frameworks. Since a majority of the team already are familiar with Python and the reasons listed above it is a good choice for back end. 
\subsubsection{Flask}
The Flask web framework is easy to use, flexible and allows for unit testing through integrated support and a quick debugger. Furthermore some members of the team are already familiar with Flask, so it is a good choice as web framework.
\subsubsection{SQL Alchemy}
Since members are experienced with SQL and the back end will be developed in Python, a logical step is using the SQL Alchemy framework in order to make the database development faster. There are also members of the team that are familiar with this framework.

\subsection{Using EhrScape}
As specified in the ASRs, the patient EHRs must be stored using the openEHR standard. Due to the time constraint and the skill constraint, the project does not have time to either train developers or to develop a server storing EHRs in accordance to the openEHR standard. In order to accommodate this requirement the project will instead use EhrScape, a health data platform. The platform contains tools for easy handling of clinical models, health data queries and vendor independent data storage. This is accessed through an API and data is stored on EhrScape's EHR server. For more information on the implementation in EhrScape, see section \ref{ehr-appendix} in the appendix.

\subsection{Using Auth0}
As stated in the ASRs, the system has to implement OAuth for authentication. Due to the time and skill constraints as well as the scope of the project, developing a authentication system utilizing OAuth would not be a good decision. In order to facilitate integration with the customers current Identity Management solution, HeartByte will implement its authentication solution through the Auth0 service. Auth0 uses OAuth 2.0, which is supported by the customer's Identity Management solution and which will make the future integration easy. Through the Auth0 API, authentication can be handled from the HeartByte system and permission scopes can be quickly set up and managed from the Auth0 webpage.

\subsection{Placement of modules}\label{placement-modules}
Due to the security concerns presented above and due to some data being shared between all users, the databases and EHR Retriever will be placed in the back end. However, there are two more modules that have to be placed in either the front end or the back end: the Rule Engine prioritizing patients and the Filtration Module filtrating patients.

\subsubsection{Rule Engine}
The Rule Engine will be placed in the front end. This is due to that using a pure two-tier, thin-client would place a large workload on the back end if a large numbers of users request data at the same time. To avoid this the Rule Engine can be placed in the front end. 

\subsubsection{Filtration Module}
Some rudimentary filtration functionality will have to be implemented in the back end, when retrieving EHR data. Otherwise every user would receive the EHR data of all patients - even patients they are not treating. However, in order to minimize total loading time the main functionality will be placed in the front end. If all relevant patients are retrieved to the client and then applying the filtration, filtration will be faster. Otherwise many calls would have to be made to the back end. This would make the loading time longer since a call will have to be made to the back end and then the back end has to call the EhrScape Server.


\section{Key abstractions}
The key abstractions of the system is the front end, the back end, an authentication server and the EHR Database. The front end is what the user interacts with and the services supporting this. The back end contains databases and functionality to get data from these databases as well as the methods for importing data from the EHR Database. The EHR Database is the external database storing the patient's EHR. The authentication server handles authentication.

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.5]{key-abstraction}
    \caption{The system and its key abstractions}
    \label{fig:key-abstractions}
\end{figure}


\subsection{Front end}
The main functionality of the front end is to create a way for the user to interact with and visualize patient data. The user will do this through the GUI, and the GUI will then communicate with the front end logic to enable the user to e.g. filter, sort and group patients. 

\subsection{Back end}
The back end serves the purpose set out in the in the ASRs and the architectural decisions. The back end will handle calls to the EHR Database and ensure that all access to patient EHRs are logged. The back end will also handle calls to the personnel database as well as storing and loading the patient views and rules for the rule engine in the customization database.

\subsection{EHR Database}
The EHR Database is the database that store the patient EHRs. It will also store any custom AQL queries that are created to access the patient EHRs and templates used to store EHR data. It will be accessed through an API.

\subsection{Authentication server}
When a user logs in, the authentication and creation of access tokens with the correct permission scopes will be handled by this server.


\section{Architectural views}
\subsection{User cases}
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.5]{user-cases}
    \caption{Significant system user cases}
    \label{fig:user-cases}
\end{figure}

In Figure \ref{fig:user-cases}, some of the more central user cases are illustrated. They are not exhaustive, but are presented to provide some context for the architectural design.

\subsection{System layers}
This section will describe components of the system in a detailed way through four layers: the GUI, the Front End Logic, the HeartByte Server and the EhrScape Server. The direction of the arrows indicate the direction of data flow.

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{box-and-line}
    \caption{A box and line diagram illustrating layers of the system and its submodules}
    \label{fig:execution-view}
\end{figure}

As seen in Figure \ref{fig:execution-view}, the front end and back end interface will utilize the facade design pattern, so coupling and modularity is ensured. Below, the modules in the figure will be described by layer.

\subsubsection{GUI Layer}
The GUI consists of four main modules. The Interface is what the user will interact with and what will display the web app. From the Interface the user can access the Patient Overview, displaying many patients, and through the Patient Selector select a specific patient to be displayed in the Patient View. 

The Interface also allows a user to log in and for superusers, to customize the rules applied in the Rule Engine through the Rule Customizer and views of the patients through the View Customizer.

\subsubsection{Front End Logic Layer}
The Front End Logic contains the "middleware" interacting with the HeartByte Server and the GUI to deliver data to the GUI. The most central module is the Client Data Retriever. This module will handle calls from Patient Overview to get general data about a group of patients and calls from Patient View to get detailed data about a specific patient. 

When Patient Overview makes a call to this module, the servers response is passed to the Rule Engine for classification of how critical the patients health status is. The classified data is then passed back to the Patient Overview. The Patient Overview can then make calls to the Filtration Module to change the filters applied to the data already retrieved. When the Patient View makes calls to the Client Data Retriever, the results returned from the server are passed directly to the Patient View.

This layer also contains the modules used for authentication as well as the customization a superuser can do. To customize classification rules, the Interface calls the Rule Customizer which in turn loads or stores rules in the Customization Database. The View Customizer works in the same fashion. The Authentication module will make a call to the Personnel Database to determine what role the user has, and thus what information should be displayed.

\subsubsection{HeartByte Server Layer}
The HeartByte Server contains the databases specific to the system and the functionality to retrieve EHRs. The System Database Management allows for storing and loading data in the Personnel Database and the Customization Database. These databases contain data about custom rules and views for specific HCUs and personnel data, respectively.

The EHR Retriever is the module responsible for loading data from EHRs. This module will recieve a call about what data to retrieve, make a call to the EhrScape Server to retrieve the requested data and return the data through the Server Endpoint. The access token, that has to be present in this call, contains information about which HCU the user belongs to. Thus it can be determined whether a patient has access to a patient or not. Regardless if this is the case or not, the patient health data is returned following the rationale laid of in Section \ref{Authentication}. However, this access is logged in the access log.

\subsubsection{EhrScape Server Layer}
This layer is a database stored on an external server, which is accessed using the EhrScape API. The API is queried using stored custom Archetype Query Language (AQL) queries as well as using its REST API. Since this is the openEHR database query language it is easy to substitute this layer with another openEHR server in the future. For more information on the implementation in EhrScape, see section \ref{ehr-appendix} in the appendix.

\subsubsection{Auth0 Server Layer}
This layer is the external authentication server. It contains a database storing the credentials of the users as well as their permission scopes. When a client makes a call to the authentication module to log in, this module calls the Auth0 API through the Client API endpoint. An access token is created using the credentials stored in the Auth DB and returned to the client.

\subsection{Deployment view}
In this section the deployment of system is discussed. Illustrated in Figure \ref{fig:departments}, there are four nodes. The Kubernetes cluster, the EhrScape server, the client and the Auth0 Server.

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{deployment-view}
    \caption{An illustration of the deployment view, illustrating \emph{some} of the components and artifacts in each node}
    \label{fig:deployment-view}
\end{figure}

The system is deployed using Kubernetes. Inside the cluster, a docker engine is run. It contains two containers built from separate base images: one for the front end and one for the back end. The front end uses a NGINX base image to serve the application to the client, NGINX is a free and open-source web server. The back end uses a python 3.6.9 base image, since it is a python Flask server.


\subsection{Authentication} \label{Authentication}
In this part the authentication aspect of the system is further explained: which permissions are needed and why.

\subsubsection{Patients and HCUs}
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{departments}
    \caption{A simple tree diagram illustrating the HCU levels and patient responsibility}
    \label{fig:departments}
\end{figure}

The users using the system belong to one or more groups. The structure of these groups are illustrated in the simple tree in Figure \ref{fig:departments}. An operation is a health care institution and could be e.g. a hospital or a health center, such as the Linköping University Hospital. These operations are divided into departments, such as Cardiology,  Infectious Diseases or Pediatrics. These departments are in turn comprised of teams.  
As illustrated, a patient is handled by one or many departments. Thus, a health care professional working at any department in Operation B is authorized to view the EHR of Patient B, but not the EHR of Patient A.
However, it is in the interest of the health care professionals working at Operation B to be able to access the EHR of Patient A, in case of an emergency. The system will facilitate this, since all access is logged this can be tracked.

\subsubsection{Permission scopes}
By analyzing the needs of users using the information above, the following permission scopes would be needed.

\begin{description}
\item [Operation] The Operation permission scopes consists of several scope, one for each operation. A user that e.g. has the \emph{Operation A} scope has access to the EHRs of all patients serviced by Operation A.
\item [Admin] The Admin permission scope allows a user to make some customization changes for the other members in the same Operation as the user. This includes changing the rules used in the Rule Engine and adding custom filtered views, through accessing the modules Rule Customizer and View Customizer illustrated in Figure \ref{fig:execution-view}.
\end{description}


\subsection{Sequence diagrams}
In this section a few relevant sequence diagrams will be displayed, to further clarify how the modules will interact in typical user cases.

\subsubsection{Calls from the Overview module}
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{overview-sequence}
    \caption{A sequence diagram illustrating how the Patient Overview calls are handled by the system}
    \label{fig:overview-sequence}
\end{figure}

Worth noting from Figure \ref{fig:overview-sequence}, is that all relevant data is retrieved to the Overview. Once the data has been retrieved, filters can be applied without retrieving the data again. Since no sensitive data will be displayed to the user through the Overview, there is no need to log this in the access log.

\subsubsection{Calls from the Patient View module}
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{patient-sequence}
    \caption{A sequence diagram illustrating how the Patient View calls are handled by the system}
    \label{fig:patient-sequence}
\end{figure}

In Figure \ref{fig:patient-sequence}, EHR data about a specific patient is retrieved. The access token, with the user's access authentication from the role inside, is passed to the EHR Retriever. After retrieving the data about the requested patient, this module will compare the operation the patient belongs to with the role of the user from the access token. If these do not match, the access is unauthorized and this will be logged before structuring the returned data and passing it to the Patient View. Note that the data is returned even though the access is unauthorized, as specified in Section \ref{Authentication}. However, no data will be returned if the access token is invalid or missing.

\subsubsection{Authentication}
\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{auth-sequence-simple}
    \caption{A sequence diagram illustrating how authentication is handled}
    \label{fig:auth-sequence-simple}
\end{figure}

As seen in Figure \ref{fig:auth-sequence-simple}, the authentication is handled through the Auth0 API. Permission scopes are manually added to users in the Auth0 dashboard. Then, when a user logs in Auth0 returns an access token containing the user's permission scope(s).

\clearpage
\section{The system in the future}
The subsections in this section will discuss what a delivery of the system will look like, how it will perform on larger data sets, how it can be maintained by the end users as well as some suggestions on future development.

\subsection{Scaleability}
In this section the factors relevant to scaling the system up, in terms of number of patients and users, will be discussed.

\subsubsection{Prioritizing of large data sets}
The Rule Engine is placed in the Front end logic layer, as seen in Figure \ref{fig:execution-view}, due to the reasons outlined in section \ref{placement-modules}. The Rule Engine only prioritizes patients based on the most recent measurements, so the classification is not computationally heavy. Due to this, a large number of patients should not affect the performance of the system in a major way. The performance would although be worse if the Rule Engine would implement more computationally heavy classification rules on a large data set, as mentioned in section \ref{trend-analysis}.

However, with a very large data set and many patients displayed in the Patient Overview another potential problem would be created. If there are e.g. 100 patients displayed unfiltered, there might be many patients classified as high priority. Then it would not be easy to see which ones are the most relevant. This can be addressed by the user, in the existing system, by filtrating on some factors to reduce the number of displayed patients, but a potentially better solution is discussed in section \ref{future-prioritization}.

\subsubsection{Filtration of large data set}
Since the filtration functionality is placed in the front end, performance could be expected to suffer when working with very large data sets. The rationale laid out in section \ref{placement-modules} is based on assumptions of a moderately sized data set and frequent filtration. However, if the data set would be very large and the filtration isn't happening frequently then the rationale might not be valid. The time lost due to calls to the back end and EhrScape could be offset by time lost due to hardware limitations on the client side. It is considered unlikely that this will be the case however, since simple tests on larger sets of patients have not shown a drop in performance.

If however performance were to be affected due to a larger number of patients, the recommended solution would be to limit the number of patients that are returned to the overview. In the current implementation, all patients that the user has authority to access are returned. This could be changed so that only patients tended  to by the user's department or team are returned. To implement this, additional data fields in the demographic database in EhrScape could be added.

\subsubsection{Increasing the number of users}
Increasing the number of users should not affect the performance of the system, since the system is designed utilizing a two-tier fat-client where no computationally heavy functionality is implemented in the back end. 

However the process of manually adding and updating permission scopes in Auth0 to each user when they change or register for the first time will be time consuming for an admin. A solution to this problem is discussed in Section \ref{RBAC-future}.

\subsection{Support}
HeartByte will work alongside the customer to implement and integrate the system. Once the implementation is secured the operation of the system will be transferred to the customer. During the transfer process, members of the HeartByte development team will be deeply involved to ensure that the customer fully understands how the system is constructed. This, alongside the documentation will enable the operation of the system to be transferred to the customer. HeartByte will also provide some support during the first year after delivery of the product. This support includes answering questions and fixing any bugs shipped in the product.

\subsection{Maintaining}
This section will handle the topic of the maintaining of the system and extending with new functionality as needed. Because the system has been built with maintainability in mind though modularity, in most cases this is relatively simple. This is not true for all functionality though, as discussed below.

\subsubsection{Adding more health data}
As of now, the system is only built to handle a few selected health data points. These include weight, blood pressure and
physical activity. If more are to be added this would mean extending the functionality in the areas below.

\begin{description}
\item [openEHR Templates] If one does not already exist for the measurement, a new template will have to be constructed and added to EhrScape. Since the customer are experienced using the tools required to do this, this would not pose a significant challange.

\item [EHR Retriever] In the EHR Retriever module in the HeartByte back end, some functionality has to be extended. A function to retrieve the individual measurements through the EhrScape API will have to be constructed.

\item [Patient View] In order to visualize the new measurements, the functionality of the Patient View has to be extended. Since the modules used to display the graphs are constructed in a modular fashion, these can easily be reused and applied to new measurements. However, this only holds true for quantitative data. The Patietn View only has functionality to plot numerical data. If the data however is either qualitative or non-numerically categorical this functionality will have to be constructed.
\end{description}

\subsubsection{Replacing EhrScape}
In the event that the customer in the future would be interested in changing the EHR Database provider this would impact the back end. There is however a big difference between replaceing EhrScape with another system using the openEHR standard and a system using some separate standard.

\begin{description}
\item [With another openEHR system] The way the EHR Retriever functions would have to be changed somewhat. The AQL queries would not have to be changed, given that all templates are transferred, since the AQL language is built on openEHR. Any calls to the REST API would however have to be changed, since they may not function the same in the new system. Since openEHR is a standard for handling EHRs, it can be assumed that the other system should have similar functionalities in its API so migrating this should not pose a major challenge.

\item [With a different system] Migrating from openEHR would pose a challenge. In order to not break functionality of other modules, the same data structure of the EHR Data has to be maintained when migrating. This would force a total rework of the EHR Retriever. The EHR Retriever has to be changed to it can retrieve data from the new source and some re-packaging of the retrieved data would have to be done. Depending on the new system, this might be quite straight forward or very difficult. If the developers would decide against re-packaging the data so other modules can remain unchanged, many modules would have to have minor changes applied to them to be able to handle the new data formats.
\end{description}


\subsection{Future development}
Due to the time constraint, some planned functionality had to be cut. In this section the modules that would implement the functionality are described, so that the system can be extended with these modules in the future.


\subsubsection{Trend analysis}\label{trend-analysis}
Due to the time constraint, the Rule Engine only classifies patients using the most recent measured value since this is simple to implement. This is however not the best solution, since the customer has mentioned that absolute values are often not the most relevant factor when prioritizing patients. The customer thinks that individual patient trends are more relevant. Originally, this was in the scope of the project but there was not enough time to implement this. 

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{trend-module}
    \caption{An overview illustrating the Trend module}
    \label{fig:trend-module}
\end{figure}

As illustrated in Figure \ref{fig:trend-module}, this module would consist of three components. A listener listening for changes in the EHR database, a trend analyzer applying some algorithm to predict future values and a trend database to store this.

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{trend-sequence}
    \caption{A sequence diagram illustrating how the Trend module would work}
    \label{fig:trend-sequence}
\end{figure}

Figure \ref{fig:trend-sequence} illustrates how it would work. Since the computations required to make these predictions would be complex, it would be best to do them only once: when the data is added to the EHR Database. Then this data is stored in a separate database to be accessed by the Client Data Getter, seen in Figure \ref{fig:execution-view}, and could be used by the Rule Engine to prioritize patients. This data could also be used in combination with the patient specific data in the Patient View, to enable the care giver to get further insights into the health trends of the patient.

Due to the modularity of the code base, this module could be implemented without a major integration effort. It would require extending the functionality of the Rule Engine to take trends into account as well as extending the visualization components in the Patient View to display the trends.


\subsubsection{A more advanced notification log}
Twp simple notification logs are implemented in the system. The first contains information about all patients handled by the user and the second is a log for a specific patient. The second contains a full log of all events, but the overview notification log for all patients is simplified. Thus the simplified log could be improved and this is discussed below.

In the system now, after the overview data is retrieved to the overview module, this data is then passed to the notification log. The log displays date of the latest measurement added for a patient, as well as which measurements were added this date. It is only the last measurement for a patient that is displayed since it would be slow to send all data for every patient to the front end, and then have the front end derive notifications from this. A better solution would be an implementation closer to the Trend Analysis module, illustrated in Figure \ref{fig:notification-module}.

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{notification-module}
    \caption{An overview illustrating the improved Notification Module}
    \label{fig:notification-module}
\end{figure}

To improve the overview notification log, the functionality should be extended in the following way: A listener listens for changes in a patients EHR. When a change happens, a notification is created in a database. The notifications are also classified based on importance. A notification that e.g. a patient has changed his emergency contact would be prioritized below e.g. a patient has added a measurement that transitions the patient from one priority class to another in the Rule Engine. The entries in the database are then retrieved and loaded into the overview notification log. This enables the log to contain rich information, but does not significantly impair the performance and loading time. The notification could contain information such as:

\begin{description}
\item [Measurement added] A new measurement has been added.
\item [Measurement deviates] A measurement that was added deviates from the previous measurements. This could be flagged as suspected faulty, as something good or as something bad.
\item [Transition in priority class] If a passenger moves from low priority to high priority, this would be logged.
\item [Significant trend change] If integrated with the Trend Analyzer, a notification could be created when a new measurement changes the previous trend or prediction significantly.
\end{description}

Implementing this would require some effort in creating the listener, the component creating the notification and the integration with the Trend Analyzer if this module is also added. However, no major changes elsewhere are required. The front end already contains the functionality necessary to display any notification as well as prioritizing and sorting among notifications.

\subsubsection{Tweaking Rule Engine based on data set size}\label{future-prioritization}
As the number of patients increase, there is a high likelihood that the Rule Engine will prioritize a large number of patients as the highest priority. In this case it will be quite hard for a health care worker to prioritize between the patients. To handle this there are two possible approaches.

\begin{description}
\item [Dynamic prioritization] The absolute number of patients classified as the highest priority class is limited. Thus, only the e.g. 20 most critical patients are classified as the highest priority. This would help the system avoid notification fatigue in its users. 
\item [Non-integer prioritization] In the system now, the classifications are made in integers. One integer corresponds to one group of patients with a condition classified as equally serious. Non-integer prioritization would change this, and instead classify a patient's condition into a non-integer number greater than zero using some mathematical formula.
\end{description}

There are some problems with both approaches. The first creates a invalid view of the patients. If there are many critical patients, this would not be reflected in the overview as some would be classified as less severe. The second approach makes prioritization less clear as a decimal number is harder to interpret than a class, such as "Critical condition" or "Low priority".

The best solution would be a combination of the two. In this, the classification into priorities is dynamic so there is a fixed maximum number of patients in the most critical classes. However, next to the symbol representing the class the non-integer number is also displayed. Thus the user can both get a good overview with groups with a graphical symbol or color as well as a number so the user can differentiate between the members of each class. Implementing this would require a re-work of the Rule Engine as well as the database storing the custom rules for the Rule Engine. 

\subsubsection{Rule-based Access Control and automation of assignment of permissions}\label{RBAC-future}
In the system now, the permission scopes of users are assigned manually in Auth0's dashboard. This solution is not scaleable, since it will require a large amount of work to add all the users and their permission scopes. A better solution would be to implement RBAC: creating roles with a set of permission scopes and then assigning the roles to a user.

In RBAC you analyze the needs of users and group them into roles. Since patient access is based on what HCU you work at and some functionality is limited to admins, it is simple to split users into groups and to see what access roles these groups require.

To further automate this solution, the roles should be automatically assigned to a user after looking them up in the personnel database. This method of authentication is illustrated in Figure \ref{fig:auth-sequence-advanced}.

\begin{figure}[h]
    \centering
    \includegraphics[scale = 0.45]{auth-sequence-advanced}
    \caption{A sequence diagram illustrating how RBAC could be implemented and automated using the personnel database}
    \label{fig:auth-sequence-advanced}
\end{figure}

Due to the time constraint, some routes are not protected sufficiently and focus was placed on finishing other modules more central to the product. Instead of using permission scopes to protect these routes, the routes were protected using the email of the user sent from the front end as a parameter in a POST-request. This is a security flaw, as someone could modify the the parameter being sent to the server. It would require this person being familiar with the email and permissions of a certain user. This needs to be changed before a deployment and would best be addressed using the Auth0 Python SDK. This allows the back end to both access the permission scope parameter in the token as well as making requests to the Auth0 server to retrieve further information about the user.

\subsubsection{Integration with other databases}
In discussions with the customer, two other databases were mentioned: both the Swedish Population Register and the customer's personnel database. In the future demographic patient data would be retrieved from the population register, which would ensure that the data in correct. The customer's personnel database would replace the personnel database in the HeartByte back end and the customer's database would be used for the RBAC illustrated in Figure \ref{fig:auth-sequence-advanced}.
Since HeartByte does not have any knowledge regarding the complexity of retrieving data from the Swedish Population Register, it is hard to estimate how much effort would be required to replace the demographic data source. HeartByte does not have any information regarding the structure of the customer's personnel database, it is also difficult to estimate the effort needed to replace the current database. Since this database most likely is not very complex, this should be relatively easy.


\subsubsection{Migrating from SQlite to PostgreSQL}
Due to the simplicity of setting up and managing the database, HeartByte opted to use SQlite to be its database system during the development process. SQlite is commonly used for development since it does not require a separate server to host the database and is easy to use. SQlite has some weaknesses that are not ideal for full scale deployment however: it has poor performance on larger data sets, no real access control and does not enforce type checking. 

PostgreSQL is more complex to set up and requires a separate server, but performs much better with larger data sets and more complex queries as well as being more strict in enforcing constraints. It also has features to support access control. This is why it is usually preferred for deployment. 

Migrating from SQlite to PostgreSQL could pose some issues since PostgreSQL applies stricter rules than SQlite. The fact that SQlite does not enforce type checking and that implementing SQlite with SQLAlchemy results in that foreign key contraints are not enforced could pose a serious issue when migrating. To mitigate this risk foreign key constraint enforcing was manually added to the SQlite database using the command below. This should make the migration much easier, if it is wanted in the future.

\begin{lstlisting}[language = SQL]
PRAGMA foreign_keys = ON;
\end{lstlisting}








\clearpage
\section{Appendix}
\subsection{OpenEHR templates, archetypes and queries}\label{ehr-appendix}
A number of templates were created in order to store the EHR data in the EhrScape server alongside some built in functionality in EhrScape. These are displayed below and can are avaliable in the lio.se accounts in EHR Studio.

\subsubsection{Basic terminology}
\begin{description}
\item[Archetype] According to the openEHR documentation, an archetype is "[...] \emph{a way of adding domain semantics to information models, while avoiding endless growth and maintenance of the latter, as would occur if a textbook approach were used to modelling.}" It is basically a set of attributes that cannot be extended.
\item[Template] A template can contain all or some attributes from one or many archetypes. You can only exclude attributes from a archetype, not add new in a template.
\item[Composition] A unit of information resulting from an interaction between a patient and a health care worker, e.g. a measurement of bloop pressure. Informally it could be called an instance of a template.
\end{description}

\subsubsection{EhrScape Demographics database}
Patient personal information was stored in EhrScape demographics database. The standard values were used, alongside some custom values to store information in the \emph{additionalInfo} parameter which can contain an infinate number of parameters. An example of the data structure is below.

\begin{lstlisting}
"party": {
        "id": "1437778",
        "version": 0,
        "firstNames": "Margarethainho",
        "lastNames": "Undulatsson",
        "additionalInfo": {
            "contactperson": "{\"name\": \"Petrainho Domherresson\",
                               \"phone\": \"0752258389\"}",
            "gender": "woman",
            "city": "Goteborg",
            "phone": "0753131105",
            "pnummer": "19690910-7761",
            "adress": "Angeredsgatanvagsgatan 27, 580 07 Goteborg",
            "ehrId": "538162e6-5191-4519-9c5a-97fe933c71f3",
            "team": "[\"Team 1\", \"Team 2\"]",
            "department": "Ortopedi",
            "operation": "Valla Vardcentral",
            "age": "51",
            "email": "margarethainho.undulatsson@fejka.nu"
        }
\end{lstlisting}

\subsubsection{Storage of EHR IDs}
To speed up the process of retrieving the patients belonging to the project, the EHR IDs of the patients were stored in a custom template called \emph{EHR-PUM-C3}. This template was based on the \emph{openEHR-EHR-COMPOSITION.encounter.v1} archetype. This intended purpose of this archetype is to be a generic container for an encouter between a patient and a health care worker, but here it was only used as a marker indicating that any patient with a composition of this template would be a patient handled by HeartByte.

\subsubsection{Measurements}
To store the measurements for each patients, a template called \emph{Measurements-C3} was created. This template can store five different measurements and contains six archetypes.

\begin{enumerate}[label=(\roman*)]
\item \emph{openEHR-EHR-COMPOSITION.encounter.v1} \\
This archetype is used to store meta-information, such as time and who made the measurement
\item \emph{openEHR-EHR-OBSERVATION.blood\_pressure.v2} \\
This archetype is used to store blood pressure
\item \emph{openEHR-EHR-OBSERVATION.body\_weight.v}2 \\
This archetype is used to store bode weight
\item \emph{openEHR-EHR-OBSERVATION.pulse.v1} \\
This archetype is used to store pulse
\item \emph{openEHR-EHR-OBSERVATION.blood\_glucose.v1} \\
This archetype is used to store blood sugar levels
\item \emph{openEHR-EHR-OBSERVATION.physicalactivityrecord.v0} \\ 
This archetype is used to store physical activity
\end{enumerate}

\subsubsection{Medications}
To store the patients medications, the template \emph{Medications} was used. This template was not created by HeartByte, but was present in EhrScape when HeartByte was given access to the system. This template contains three archetypes. 

\begin{enumerate}[label=(\roman*)]
\item \emph{openEHR-EHR-COMPOSITION.encounter.v1} \\
This archetype is used to store meta-information, such as time and who prescribed the medication
\item \emph{openEHR-EHR-INSTRUCTION.medication.v1} \\
This archetype is used to store how often a patient should take their medication
\item \emph{openEHR-EHR-CLUSTER.medication\_amount.v1} \\
This archetype is used to store how much of a medication the patient should take
\end{enumerate}


\subsubsection{Diagnoses}
To store the diagnosis, the template \emph{Medical Diagnosis} was used. This template was not created by HeartByte, but was present in EhrScape when HeartByte was given access to the system. This template contains three archetypes.

\begin{enumerate}[label=(\roman*)]
\item \emph{openEHR-EHR-COMPOSITION.encounter.v1} \\
This archetype is used to store meta-information, such as time and who made the diagnosis
\item \emph{openEHR-EHR-EVALUATION.problem\_diagnosis.v1} \\
This archetype is used to store details about a single, identified health problem or diagnosis
\item \emph{openEHR-EHR-CLUSTER.problem\_status.v1} \\
This archetype is used to store the status of the diagnosis
\end{enumerate}


\subsubsection{AQL queries used}
To fetch data from EhrScape AQL queries were used, except for the demographics:

\begin{enumerate}[label=(\roman*)]
\item Retrieving the EHRs of patients handled by HeartByte. Note the use of the template \emph{EHR-PUM-C3} to indicate that a patient belongs to HeartByte:
\begin{lstlisting}[language = AQL]
SELECT e/ehr_id/value as id
FROM EHR e
CONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]
WHERE c/name/value='EHR-PUM-C3'
OFFSET 0;
\end{lstlisting}
    
\item Retrieving all measurements of a patient, given the patients EHR ID: 
\begin{lstlisting}[language = AQL]
SELECT 
x/data[at0002]/events[at0003]/data[at0001]/items[at0004,'Pulse Rate']/value 
as pulse,
a/data[at0001]/events[at0002]/data[at0003]/items[at0011]/value as exercise,
o/data[at0002]/events[at0003]/data[at0001]/items[at0004]/value as bodyweight,
w/data[at0001]/events[at0002]/data[at0003]/items[at0004]/value as bloodsugar,
i/data[at0001]/events[at0006]/data[at0003]/items[at0004]/value as systolic,
i/data[at0001]/events[at0006]/data[at0003]/items[at0005]/value as diastolic,
w/data[at0001]/events[at0002]/time/value as time
FROM EHR e
CONTAINS COMPOSITION c
CONTAINS (OBSERVATION x[openEHR-EHR-OBSERVATION.pulse.v1] and 
OBSERVATION a[openEHR-EHR-OBSERVATION.physicalactivityrecord.v0] and 
OBSERVATION o[openEHR-EHR-OBSERVATION.body_weight.v2] and 
OBSERVATION w[openEHR-EHR-OBSERVATION.blood_glucose.v1] and 
OBSERVATION i[openEHR-EHR-OBSERVATION.blood_pressure.v2]) 
WHERE e/ehr_id/value = EHR_ID
OFFSET 0;
\end{lstlisting}
    
\item Retrieving all medications a patient is taking, given its EHR ID:
\begin{lstlisting}[language = AQL]
SELECT n/activities[at0001]/description[at0002]/items[at0003]/value as med,
n/activities[at0001]/description[at0002]/items[at0009]/value as directions,
l/items[at0001,'Quantity']/value as quantity,
/items[at0003]/value as intakeform,
n/activities[at0001]/description[at0002]/items[at0044]/value as frequency,
n/activities[at0001]/description[at0002]/items[at0035]/value as daily
FROM EHR e
CONTAINS COMPOSITION c
CONTAINS INSTRUCTION n[openEHR-EHR-INSTRUCTION.medication.v1] 
CONTAINS (CLUSTER l[openEHR-EHR-CLUSTER.medication_amount.v1]) 
WHERE e/ehr_id/value = EHR_ID
OFFSET 0;
\end{lstlisting}

\clearpage
\item Retrieving all diagnoses a patient has, given its EHR ID:
\begin{lstlisting}[language = AQL]
SELECT y/data[at0001]/items[at0009]/value as diagnos
FROM EHR e
CONTAINS COMPOSITION c[openEHR-EHR-COMPOSITION.encounter.v1]
CONTAINS EVALUATION y[openEHR-EHR-EVALUATION.problem_diagnosis.v1] 
WHERE c/name/value='Medical diagnosis' and e/ehr_id/value = EHR_ID
OFFSET 0;
\end{lstlisting}
\end{enumerate}
\end{document}
